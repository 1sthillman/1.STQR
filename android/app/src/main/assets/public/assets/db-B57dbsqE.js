const ee="modulepreload",te=function(o){return"/"+o},W={},re=function(e,t,r){let n=Promise.resolve();if(t&&t.length>0){let a=function(c){return Promise.all(c.map(P=>Promise.resolve(P).then(y=>({status:"fulfilled",value:y}),y=>({status:"rejected",reason:y}))))};document.getElementsByTagName("link");const i=document.querySelector("meta[property=csp-nonce]"),l=(i==null?void 0:i.nonce)||(i==null?void 0:i.getAttribute("nonce"));n=a(t.map(c=>{if(c=te(c),c in W)return;W[c]=!0;const P=c.endsWith(".css"),y=P?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${c}"]${y}`))return;const f=document.createElement("link");if(f.rel=P?"stylesheet":ee,P||(f.as="script"),f.crossOrigin="",f.href=c,l&&f.setAttribute("nonce",l),document.head.appendChild(f),P)return new Promise((k,_)=>{f.addEventListener("load",k),f.addEventListener("error",()=>_(new Error(`Unable to preload CSS for ${c}`)))})}))}function s(a){const i=new Event("vite:preloadError",{cancelable:!0});if(i.payload=a,window.dispatchEvent(i),!i.defaultPrevented)throw a}return n.then(a=>{for(const i of a||[])i.status==="rejected"&&s(i.reason);return e().catch(s)})};/*! Capacitor: https://capacitorjs.com/ - MIT License */const se=o=>{const e=new Map;e.set("web",{name:"web"});const t=o.CapacitorPlatforms||{currentPlatform:{name:"web"},platforms:e},r=(s,a)=>{t.platforms.set(s,a)},n=s=>{t.platforms.has(s)&&(t.currentPlatform=t.platforms.get(s))};return t.addPlatform=r,t.setPlatform=n,t},ne=o=>o.CapacitorPlatforms=se(o),I=ne(typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});I.addPlatform;I.setPlatform;var E;(function(o){o.Unimplemented="UNIMPLEMENTED",o.Unavailable="UNAVAILABLE"})(E||(E={}));class O extends Error{constructor(e,t,r){super(e),this.message=e,this.code=t,this.data=r}}const ie=o=>{var e,t;return o!=null&&o.androidBridge?"android":!((t=(e=o==null?void 0:o.webkit)===null||e===void 0?void 0:e.messageHandlers)===null||t===void 0)&&t.bridge?"ios":"web"},oe=o=>{var e,t,r,n,s;const a=o.CapacitorCustomPlatform||null,i=o.Capacitor||{},l=i.Plugins=i.Plugins||{},c=o.CapacitorPlatforms,P=()=>a!==null?a.name:ie(o),y=((e=c==null?void 0:c.currentPlatform)===null||e===void 0?void 0:e.getPlatform)||P,f=()=>y()!=="web",k=((t=c==null?void 0:c.currentPlatform)===null||t===void 0?void 0:t.isNativePlatform)||f,_=d=>{const u=x.get(d);return!!(u!=null&&u.platforms.has(y())||A(d))},Q=((r=c==null?void 0:c.currentPlatform)===null||r===void 0?void 0:r.isPluginAvailable)||_,J=d=>{var u;return(u=i.PluginHeaders)===null||u===void 0?void 0:u.find(C=>C.name===d)},A=((n=c==null?void 0:c.currentPlatform)===null||n===void 0?void 0:n.getPluginHeader)||J,G=d=>o.console.error(d),V=(d,u,C)=>Promise.reject(`${C} does not have an implementation of "${u}".`),x=new Map,K=(d,u={})=>{const C=x.get(d);if(C)return C.proxy;const j=y(),q=A(d);let v;const X=async()=>(!v&&j in u?v=typeof u[j]=="function"?v=await u[j]():v=u[j]:a!==null&&!v&&"web"in u&&(v=typeof u.web=="function"?v=await u.web():v=u.web),v),Y=(h,m)=>{var g,b;if(q){const p=q==null?void 0:q.methods.find(w=>m===w.name);if(p)return p.rtype==="promise"?w=>i.nativePromise(d,m.toString(),w):(w,L)=>i.nativeCallback(d,m.toString(),w,L);if(h)return(g=h[m])===null||g===void 0?void 0:g.bind(h)}else{if(h)return(b=h[m])===null||b===void 0?void 0:b.bind(h);throw new O(`"${d}" plugin is not implemented on ${j}`,E.Unimplemented)}},N=h=>{let m;const g=(...b)=>{const p=X().then(w=>{const L=Y(w,h);if(L){const S=L(...b);return m=S==null?void 0:S.remove,S}else throw new O(`"${d}.${h}()" is not implemented on ${j}`,E.Unimplemented)});return h==="addListener"&&(p.remove=async()=>m()),p};return g.toString=()=>`${h.toString()}() { [capacitor code] }`,Object.defineProperty(g,"name",{value:h,writable:!1,configurable:!1}),g},R=N("addListener"),U=N("removeListener"),Z=(h,m)=>{const g=R({eventName:h},m),b=async()=>{const w=await g;U({eventName:h,callbackId:w},m)},p=new Promise(w=>g.then(()=>w({remove:b})));return p.remove=async()=>{await b()},p},T=new Proxy({},{get(h,m){switch(m){case"$$typeof":return;case"toJSON":return()=>({});case"addListener":return q?Z:R;case"removeListener":return U;default:return N(m)}}});return l[d]=T,x.set(d,{name:d,proxy:T,platforms:new Set([...Object.keys(u),...q?[j]:[]])}),T},z=((s=c==null?void 0:c.currentPlatform)===null||s===void 0?void 0:s.registerPlugin)||K;return i.convertFileSrc||(i.convertFileSrc=d=>d),i.getPlatform=y,i.handleError=G,i.isNativePlatform=k,i.isPluginAvailable=Q,i.pluginMethodNoop=V,i.registerPlugin=z,i.Exception=O,i.DEBUG=!!i.DEBUG,i.isLoggingEnabled=!!i.isLoggingEnabled,i.platform=i.getPlatform(),i.isNative=i.isNativePlatform(),i},ae=o=>o.Capacitor=oe(o),D=ae(typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{}),$=D.registerPlugin;D.Plugins;class H{constructor(e){this.listeners={},this.retainedEventArguments={},this.windowListeners={},e&&(this.config=e)}addListener(e,t){let r=!1;this.listeners[e]||(this.listeners[e]=[],r=!0),this.listeners[e].push(t);const s=this.windowListeners[e];s&&!s.registered&&this.addWindowListener(s),r&&this.sendRetainedArgumentsForEvent(e);const a=async()=>this.removeListener(e,t);return Promise.resolve({remove:a})}async removeAllListeners(){this.listeners={};for(const e in this.windowListeners)this.removeWindowListener(this.windowListeners[e]);this.windowListeners={}}notifyListeners(e,t,r){const n=this.listeners[e];if(!n){if(r){let s=this.retainedEventArguments[e];s||(s=[]),s.push(t),this.retainedEventArguments[e]=s}return}n.forEach(s=>s(t))}hasListeners(e){return!!this.listeners[e].length}registerWindowListener(e,t){this.windowListeners[t]={registered:!1,windowEventName:e,pluginEventName:t,handler:r=>{this.notifyListeners(t,r)}}}unimplemented(e="not implemented"){return new D.Exception(e,E.Unimplemented)}unavailable(e="not available"){return new D.Exception(e,E.Unavailable)}async removeListener(e,t){const r=this.listeners[e];if(!r)return;const n=r.indexOf(t);this.listeners[e].splice(n,1),this.listeners[e].length||this.removeWindowListener(this.windowListeners[e])}addWindowListener(e){window.addEventListener(e.windowEventName,e.handler),e.registered=!0}removeWindowListener(e){e&&(window.removeEventListener(e.windowEventName,e.handler),e.registered=!1)}sendRetainedArgumentsForEvent(e){const t=this.retainedEventArguments[e];t&&(delete this.retainedEventArguments[e],t.forEach(r=>{this.notifyListeners(e,r)}))}}const M=o=>encodeURIComponent(o).replace(/%(2[346B]|5E|60|7C)/g,decodeURIComponent).replace(/[()]/g,escape),F=o=>o.replace(/(%[\dA-F]{2})+/gi,decodeURIComponent);class ce extends H{async getCookies(){const e=document.cookie,t={};return e.split(";").forEach(r=>{if(r.length<=0)return;let[n,s]=r.replace(/=/,"CAP_COOKIE").split("CAP_COOKIE");n=F(n).trim(),s=F(s).trim(),t[n]=s}),t}async setCookie(e){try{const t=M(e.key),r=M(e.value),n=`; expires=${(e.expires||"").replace("expires=","")}`,s=(e.path||"/").replace("path=",""),a=e.url!=null&&e.url.length>0?`domain=${e.url}`:"";document.cookie=`${t}=${r||""}${n}; path=${s}; ${a};`}catch(t){return Promise.reject(t)}}async deleteCookie(e){try{document.cookie=`${e.key}=; Max-Age=0`}catch(t){return Promise.reject(t)}}async clearCookies(){try{const e=document.cookie.split(";")||[];for(const t of e)document.cookie=t.replace(/^ +/,"").replace(/=.*/,`=;expires=${new Date().toUTCString()};path=/`)}catch(e){return Promise.reject(e)}}async clearAllCookies(){try{await this.clearCookies()}catch(e){return Promise.reject(e)}}}$("CapacitorCookies",{web:()=>new ce});const le=async o=>new Promise((e,t)=>{const r=new FileReader;r.onload=()=>{const n=r.result;e(n.indexOf(",")>=0?n.split(",")[1]:n)},r.onerror=n=>t(n),r.readAsDataURL(o)}),de=(o={})=>{const e=Object.keys(o);return Object.keys(o).map(n=>n.toLocaleLowerCase()).reduce((n,s,a)=>(n[s]=o[e[a]],n),{})},ue=(o,e=!0)=>o?Object.entries(o).reduce((r,n)=>{const[s,a]=n;let i,l;return Array.isArray(a)?(l="",a.forEach(c=>{i=e?encodeURIComponent(c):c,l+=`${s}=${i}&`}),l.slice(0,-1)):(i=e?encodeURIComponent(a):a,l=`${s}=${i}`),`${r}&${l}`},"").substr(1):null,he=(o,e={})=>{const t=Object.assign({method:o.method||"GET",headers:o.headers},e),n=de(o.headers)["content-type"]||"";if(typeof o.data=="string")t.body=o.data;else if(n.includes("application/x-www-form-urlencoded")){const s=new URLSearchParams;for(const[a,i]of Object.entries(o.data||{}))s.set(a,i);t.body=s.toString()}else if(n.includes("multipart/form-data")||o.data instanceof FormData){const s=new FormData;if(o.data instanceof FormData)o.data.forEach((i,l)=>{s.append(l,i)});else for(const i of Object.keys(o.data))s.append(i,o.data[i]);t.body=s;const a=new Headers(t.headers);a.delete("content-type"),t.headers=a}else(n.includes("application/json")||typeof o.data=="object")&&(t.body=JSON.stringify(o.data));return t};class me extends H{async request(e){const t=he(e,e.webFetchExtra),r=ue(e.params,e.shouldEncodeUrlParams),n=r?`${e.url}?${r}`:e.url,s=await fetch(n,t),a=s.headers.get("content-type")||"";let{responseType:i="text"}=s.ok?e:{};a.includes("application/json")&&(i="json");let l,c;switch(i){case"arraybuffer":case"blob":c=await s.blob(),l=await le(c);break;case"json":l=await s.json();break;case"document":case"text":default:l=await s.text()}const P={};return s.headers.forEach((y,f)=>{P[f]=y}),{data:l,headers:P,status:s.status,url:s.url}}async get(e){return this.request(Object.assign(Object.assign({},e),{method:"GET"}))}async post(e){return this.request(Object.assign(Object.assign({},e),{method:"POST"}))}async put(e){return this.request(Object.assign(Object.assign({},e),{method:"PUT"}))}async patch(e){return this.request(Object.assign(Object.assign({},e),{method:"PATCH"}))}async delete(e){return this.request(Object.assign(Object.assign({},e),{method:"DELETE"}))}}$("CapacitorHttp",{web:()=>new me});class ye{constructor(e){this.sqlite=e,this._connectionDict=new Map}async initWebStore(){try{return await this.sqlite.initWebStore(),Promise.resolve()}catch(e){return Promise.reject(e)}}async saveToStore(e){try{return await this.sqlite.saveToStore({database:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async saveToLocalDisk(e){try{return await this.sqlite.saveToLocalDisk({database:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async getFromLocalDiskToStore(e){const t=e??!0;try{return await this.sqlite.getFromLocalDiskToStore({overwrite:t}),Promise.resolve()}catch(r){return Promise.reject(r)}}async echo(e){try{const t=await this.sqlite.echo({value:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isSecretStored(){try{const e=await this.sqlite.isSecretStored();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async setEncryptionSecret(e){try{return await this.sqlite.setEncryptionSecret({passphrase:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async changeEncryptionSecret(e,t){try{return await this.sqlite.changeEncryptionSecret({passphrase:e,oldpassphrase:t}),Promise.resolve()}catch(r){return Promise.reject(r)}}async clearEncryptionSecret(){try{return await this.sqlite.clearEncryptionSecret(),Promise.resolve()}catch(e){return Promise.reject(e)}}async checkEncryptionSecret(e){try{const t=await this.sqlite.checkEncryptionSecret({passphrase:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async addUpgradeStatement(e,t){try{return e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.addUpgradeStatement({database:e,upgrade:t}),Promise.resolve()}catch(r){return Promise.reject(r)}}async createConnection(e,t,r,n,s){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.createConnection({database:e,encrypted:t,mode:r,version:n,readonly:s});const a=new B(e,s,this.sqlite),i=s?`RO_${e}`:`RW_${e}`;return this._connectionDict.set(i,a),Promise.resolve(a)}catch(a){return Promise.reject(a)}}async closeConnection(e,t){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.closeConnection({database:e,readonly:t});const r=t?`RO_${e}`:`RW_${e}`;return this._connectionDict.delete(r),Promise.resolve()}catch(r){return Promise.reject(r)}}async isConnection(e,t){const r={};e.endsWith(".db")&&(e=e.slice(0,-3));const n=t?`RO_${e}`:`RW_${e}`;return r.result=this._connectionDict.has(n),Promise.resolve(r)}async retrieveConnection(e,t){e.endsWith(".db")&&(e=e.slice(0,-3));const r=t?`RO_${e}`:`RW_${e}`;if(this._connectionDict.has(r)){const n=this._connectionDict.get(r);return typeof n<"u"?Promise.resolve(n):Promise.reject(`Connection ${e} is undefined`)}else return Promise.reject(`Connection ${e} does not exist`)}async getNCDatabasePath(e,t){try{const r=await this.sqlite.getNCDatabasePath({path:e,database:t});return Promise.resolve(r)}catch(r){return Promise.reject(r)}}async createNCConnection(e,t){try{await this.sqlite.createNCConnection({databasePath:e,version:t});const r=new B(e,!0,this.sqlite),n=`RO_${e})`;return this._connectionDict.set(n,r),Promise.resolve(r)}catch(r){return Promise.reject(r)}}async closeNCConnection(e){try{await this.sqlite.closeNCConnection({databasePath:e});const t=`RO_${e})`;return this._connectionDict.delete(t),Promise.resolve()}catch(t){return Promise.reject(t)}}async isNCConnection(e){const t={},r=`RO_${e})`;return t.result=this._connectionDict.has(r),Promise.resolve(t)}async retrieveNCConnection(e){if(this._connectionDict.has(e)){const t=`RO_${e})`,r=this._connectionDict.get(t);return typeof r<"u"?Promise.resolve(r):Promise.reject(`Connection ${e} is undefined`)}else return Promise.reject(`Connection ${e} does not exist`)}async isNCDatabase(e){try{const t=await this.sqlite.isNCDatabase({databasePath:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async retrieveAllConnections(){return this._connectionDict}async closeAllConnections(){const e=new Map;try{for(const t of this._connectionDict.keys()){const r=t.substring(3),n=t.substring(0,3)==="RO_";await this.sqlite.closeConnection({database:r,readonly:n}),e.set(t,null)}for(const t of e.keys())this._connectionDict.delete(t);return Promise.resolve()}catch(t){return Promise.reject(t)}}async checkConnectionsConsistency(){try{const e=[...this._connectionDict.keys()],t=[],r=[];for(const s of e)t.push(s.substring(0,2)),r.push(s.substring(3));const n=await this.sqlite.checkConnectionsConsistency({dbNames:r,openModes:t});return n.result||(this._connectionDict=new Map),Promise.resolve(n)}catch(e){return this._connectionDict=new Map,Promise.reject(e)}}async importFromJson(e){try{const t=await this.sqlite.importFromJson({jsonstring:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isJsonValid(e){try{const t=await this.sqlite.isJsonValid({jsonstring:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async copyFromAssets(e){const t=e??!0;try{return await this.sqlite.copyFromAssets({overwrite:t}),Promise.resolve()}catch(r){return Promise.reject(r)}}async getFromHTTPRequest(e,t){const r=t??!0;try{return await this.sqlite.getFromHTTPRequest({url:e,overwrite:r}),Promise.resolve()}catch(n){return Promise.reject(n)}}async isDatabaseEncrypted(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{const t=await this.sqlite.isDatabaseEncrypted({database:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isInConfigEncryption(){try{const e=await this.sqlite.isInConfigEncryption();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isInConfigBiometricAuth(){try{const e=await this.sqlite.isInConfigBiometricAuth();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isDatabase(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{const t=await this.sqlite.isDatabase({database:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async getDatabaseList(){try{const t=(await this.sqlite.getDatabaseList()).values;t.sort();const r={values:t};return Promise.resolve(r)}catch(e){return Promise.reject(e)}}async getMigratableDbList(e){const t=e||"default";try{const r=await this.sqlite.getMigratableDbList({folderPath:t});return Promise.resolve(r)}catch(r){return Promise.reject(r)}}async addSQLiteSuffix(e,t){const r=e||"default",n=t||[];try{const s=await this.sqlite.addSQLiteSuffix({folderPath:r,dbNameList:n});return Promise.resolve(s)}catch(s){return Promise.reject(s)}}async deleteOldDatabases(e,t){const r=e||"default",n=t||[];try{const s=await this.sqlite.deleteOldDatabases({folderPath:r,dbNameList:n});return Promise.resolve(s)}catch(s){return Promise.reject(s)}}async moveDatabasesAndAddSuffix(e,t){const r=e||"default",n=t||[];return this.sqlite.moveDatabasesAndAddSuffix({folderPath:r,dbNameList:n})}}class B{constructor(e,t,r){this.dbName=e,this.readonly=t,this.sqlite=r}getConnectionDBName(){return this.dbName}getConnectionReadOnly(){return this.readonly}async open(){try{return await this.sqlite.open({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async close(){try{return await this.sqlite.close({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async beginTransaction(){try{const e=await this.sqlite.beginTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async commitTransaction(){try{const e=await this.sqlite.commitTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async rollbackTransaction(){try{const e=await this.sqlite.rollbackTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTransactionActive(){try{const e=await this.sqlite.isTransactionActive({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async loadExtension(e){try{return await this.sqlite.loadExtension({database:this.dbName,path:e,readonly:this.readonly}),Promise.resolve()}catch(t){return Promise.reject(t)}}async enableLoadExtension(e){try{return await this.sqlite.enableLoadExtension({database:this.dbName,toggle:e,readonly:this.readonly}),Promise.resolve()}catch(t){return Promise.reject(t)}}async getUrl(){try{const e=await this.sqlite.getUrl({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getVersion(){try{const e=await this.sqlite.getVersion({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getTableList(){try{const e=await this.sqlite.getTableList({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async execute(e,t=!0,r=!0){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{const n=await this.sqlite.execute({database:this.dbName,statements:e,transaction:t,readonly:!1,isSQL92:r});return Promise.resolve(n)}}catch(n){return Promise.reject(n)}}async query(e,t,r=!0){let n;try{return t&&t.length>0?n=await this.sqlite.query({database:this.dbName,statement:e,values:t,readonly:this.readonly,isSQL92:!0}):n=await this.sqlite.query({database:this.dbName,statement:e,values:[],readonly:this.readonly,isSQL92:r}),n=await this.reorderRows(n),Promise.resolve(n)}catch(s){return Promise.reject(s)}}async run(e,t,r=!0,n="no",s=!0){let a;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(t&&t.length>0?a=await this.sqlite.run({database:this.dbName,statement:e,values:t,transaction:r,readonly:!1,returnMode:n,isSQL92:!0}):a=await this.sqlite.run({database:this.dbName,statement:e,values:[],transaction:r,readonly:!1,returnMode:n,isSQL92:s}),a.changes=await this.reorderRows(a.changes),Promise.resolve(a))}catch(i){return Promise.reject(i)}}async executeSet(e,t=!0,r="no",n=!0){let s;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(s=await this.sqlite.executeSet({database:this.dbName,set:e,transaction:t,readonly:!1,returnMode:r,isSQL92:n}),s.changes=await this.reorderRows(s.changes),Promise.resolve(s))}catch(a){return Promise.reject(a)}}async isExists(){try{const e=await this.sqlite.isDBExists({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTable(e){try{const t=await this.sqlite.isTableExists({database:this.dbName,table:e,readonly:this.readonly});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isDBOpen(){try{const e=await this.sqlite.isDBOpen({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async delete(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.deleteDatabase({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}}async createSyncTable(){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{const e=await this.sqlite.createSyncTable({database:this.dbName,readonly:!1});return Promise.resolve(e)}}catch(e){return Promise.reject(e)}}async setSyncDate(e){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.setSyncDate({database:this.dbName,syncdate:e,readonly:!1}),Promise.resolve())}catch(t){return Promise.reject(t)}}async getSyncDate(){try{const e=await this.sqlite.getSyncDate({database:this.dbName,readonly:this.readonly});let t="";return e.syncDate>0&&(t=new Date(e.syncDate*1e3).toISOString()),Promise.resolve(t)}catch(e){return Promise.reject(e)}}async exportToJson(e,t=!1){try{const r=await this.sqlite.exportToJson({database:this.dbName,jsonexportmode:e,readonly:this.readonly,encrypted:t});return Promise.resolve(r)}catch(r){return Promise.reject(r)}}async deleteExportedRows(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.deleteExportedRows({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}}async executeTransaction(e,t=!0){let r=0,n=!1;if(this.readonly)return Promise.reject("not allowed in read-only mode");if(await this.sqlite.beginTransaction({database:this.dbName}),n=await this.sqlite.isTransactionActive({database:this.dbName}),!n)return Promise.reject("After Begin Transaction, no transaction active");try{for(const i of e){if(typeof i!="object"||!("statement"in i))throw new Error("Error a task.statement must be provided");if("values"in i&&i.values&&i.values.length>0){const l=i.statement.toUpperCase().includes("RETURNING")?"all":"no",c=await this.sqlite.run({database:this.dbName,statement:i.statement,values:i.values,transaction:!1,readonly:!1,returnMode:l,isSQL92:t});if(c.changes.changes<0)throw new Error("Error in transaction method run ");r+=c.changes.changes}else{const l=await this.sqlite.execute({database:this.dbName,statements:i.statement,transaction:!1,readonly:!1});if(l.changes.changes<0)throw new Error("Error in transaction method execute ");r+=l.changes.changes}}const s=await this.sqlite.commitTransaction({database:this.dbName});r+=s.changes.changes;const a={changes:{changes:r}};return Promise.resolve(a)}catch(s){const a=s.message?s.message:s;return await this.sqlite.rollbackTransaction({database:this.dbName}),Promise.reject(a)}}async reorderRows(e){const t=e;if(e!=null&&e.values&&typeof e.values[0]=="object"&&Object.keys(e.values[0]).includes("ios_columns")){const r=e.values[0].ios_columns,n=[];for(let s=1;s<e.values.length;s++){const a=e.values[s],i={};for(const l of r)i[l]=a[l];n.push(i)}t.values=n}return Promise.resolve(t)}}const fe=$("CapacitorSQLite",{web:()=>re(()=>import("./web-D9F6nfBD.js"),[]).then(o=>new o.CapacitorSQLiteWeb),electron:()=>window.CapacitorCustomPlatform.plugins.CapacitorSQLite});export{O as C,E,ye as S,H as W,re as _,D as a,fe as b,he as c,$ as r};
